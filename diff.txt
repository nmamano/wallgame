diff --git a/frontend/src/routes/past-games.tsx b/frontend/src/routes/past-games.tsx
index b0e1019..6914f6c 100644
--- a/frontend/src/routes/past-games.tsx
+++ b/frontend/src/routes/past-games.tsx
@@ -1,5 +1,6 @@
 import { createFileRoute, useNavigate } from "@tanstack/react-router";
 import { useState } from "react";
+import { useQuery } from "@tanstack/react-query";
 import { Card } from "@/components/ui/card";
 import { Button } from "@/components/ui/button";
 import { Input } from "@/components/ui/input";
@@ -20,70 +21,135 @@ import {
   TableRow,
 } from "@/components/ui/table";
 import { Badge } from "@/components/ui/badge";
-import { Eye } from "lucide-react";
+import { Eye, Loader2 } from "lucide-react";
+import { api } from "@/lib/api";
+import type { PastGamesResponse } from "../../../shared/contracts/games";
+import { presentPastGameRow } from "@/lib/past-games";
 
 export const Route = createFileRoute("/past-games")({
   component: PastGames,
 });
 
+const PAGE_SIZE = 100;
+
+interface Filters {
+  variant: "all" | "standard" | "classic";
+  rated: "all" | "yes" | "no";
+  timeControl: "all" | "bullet" | "blitz" | "rapid" | "classical";
+  boardSize: "all" | "small" | "medium" | "large";
+  player1: string;
+  player2: string;
+  eloMin: string;
+  eloMax: string;
+}
+
+const defaultFilters: Filters = {
+  variant: "all",
+  rated: "all",
+  timeControl: "all",
+  boardSize: "all",
+  player1: "",
+  player2: "",
+  eloMin: "",
+  eloMax: "",
+};
+
+const buildPastGamesQuery = (
+  filters: Filters,
+  page: number,
+): Record<string, string | number> => {
+  const query: Record<string, string | number> = {
+    page,
+    pageSize: PAGE_SIZE,
+  };
+
+  if (filters.variant !== "all") {
+    query.variant = filters.variant;
+  }
+  if (filters.rated !== "all") {
+    query.rated = filters.rated;
+  }
+  if (filters.timeControl !== "all") {
+    query.timeControl = filters.timeControl;
+  }
+  if (filters.boardSize !== "all") {
+    query.boardSize = filters.boardSize;
+  }
+
+  const minElo = Number.parseInt(filters.eloMin, 10);
+  if (Number.isFinite(minElo) && minElo >= 0) {
+    query.minElo = minElo;
+  }
+  const maxElo = Number.parseInt(filters.eloMax, 10);
+  if (Number.isFinite(maxElo) && maxElo >= 0) {
+    query.maxElo = maxElo;
+  }
+
+  const player1 = filters.player1.trim();
+  if (player1) {
+    query.player1 = player1;
+  }
+  const player2 = filters.player2.trim();
+  if (player2) {
+    query.player2 = player2;
+  }
+
+  return query;
+};
+
+const fetchPastGames = async (
+  filters: Filters,
+  page: number,
+): Promise<PastGamesResponse> => {
+  const query = buildPastGamesQuery(filters, page);
+  const res = await api.games.past.$get({ query });
+  if (!res.ok) {
+    const data = (await res.json().catch(() => null)) as {
+      error?: string;
+    } | null;
+    throw new Error(
+      data?.error ?? `Request failed: ${res.status} ${res.statusText}`,
+    );
+  }
+  return res.json() as Promise<PastGamesResponse>;
+};
+
 function PastGames() {
   const navigate = useNavigate();
 
-  const [filters, setFilters] = useState({
-    variant: "all",
-    rated: "all",
-    timeControl: "all",
-    boardSize: "all",
-    player1: "",
-    player2: "",
-    eloMin: "",
-    eloMax: "",
+  const [filters, setFilters] = useState<Filters>(defaultFilters);
+  const [page, setPage] = useState<number>(1);
+
+  const { data, isPending, error } = useQuery({
+    queryKey: [
+      "past-games",
+      page,
+      PAGE_SIZE,
+      filters.variant,
+      filters.rated,
+      filters.timeControl,
+      filters.boardSize,
+      filters.player1,
+      filters.player2,
+      filters.eloMin,
+      filters.eloMax,
+    ],
+    queryFn: () => fetchPastGames(filters, page),
   });
 
-  // Mock data
-  const games = [
-    {
-      id: "1",
-      variant: "Standard",
-      rated: true,
-      timeControl: "rapid (10+2)",
-      boardSize: "medium (8x8)",
-      players: "Alice (1450) vs Bob (1420)",
-      winner: "Alice",
-      moves: 45,
-      views: 127,
-      date: "2025-01-10",
-    },
-    {
-      id: "2",
-      variant: "Standard",
-      rated: false,
-      timeControl: "blitz (3+2)",
-      boardSize: "small (6x6)",
-      players: "Charlie (1580) vs Diana (1590)",
-      winner: "Draw",
-      moves: 32,
-      views: 89,
-      date: "2025-01-09",
-    },
-    {
-      id: "3",
-      variant: "Classic",
-      rated: true,
-      timeControl: "rapid (10+2)",
-      boardSize: "large (10x10)",
-      players: "Eve (1720) vs Frank (1680)",
-      winner: "Eve",
-      moves: 61,
-      views: 234,
-      date: "2025-01-08",
-    },
-  ];
+  const games = data?.games ?? [];
+  const rows = games.map((game) => presentPastGameRow(game));
+  const hasMore = data?.hasMore ?? false;
 
   const handleWatchGame = (gameId: string) => {
     void navigate({ to: `/game/${gameId}` });
   };
 
+  const updateFilters = (next: Partial<Filters>) => {
+    setFilters((prev) => ({ ...prev, ...next }));
+    setPage(1);
+  };
+
   return (
     <div className="container mx-auto py-8 px-4">
       <h1 className="text-4xl font-serif font-bold tracking-tight text-foreground mb-8 text-balance">
@@ -102,7 +168,9 @@ function PastGames() {
             <Select
               value={filters.variant}
               onValueChange={(value) =>
-                setFilters({ ...filters, variant: value })
+                updateFilters({
+                  variant: value as Filters["variant"],
+                })
               }
             >
               <SelectTrigger className="bg-background">
@@ -121,7 +189,9 @@ function PastGames() {
             <Select
               value={filters.rated}
               onValueChange={(value) =>
-                setFilters({ ...filters, rated: value })
+                updateFilters({
+                  rated: value as Filters["rated"],
+                })
               }
             >
               <SelectTrigger className="bg-background">
@@ -140,7 +210,9 @@ function PastGames() {
             <Select
               value={filters.timeControl}
               onValueChange={(value) =>
-                setFilters({ ...filters, timeControl: value })
+                updateFilters({
+                  timeControl: value as Filters["timeControl"],
+                })
               }
             >
               <SelectTrigger className="bg-background">
@@ -161,7 +233,9 @@ function PastGames() {
             <Select
               value={filters.boardSize}
               onValueChange={(value) =>
-                setFilters({ ...filters, boardSize: value })
+                updateFilters({
+                  boardSize: value as Filters["boardSize"],
+                })
               }
             >
               <SelectTrigger className="bg-background">
@@ -182,7 +256,9 @@ function PastGames() {
               placeholder="Enter player name..."
               value={filters.player1}
               onChange={(e) =>
-                setFilters({ ...filters, player1: e.target.value })
+                updateFilters({
+                  player1: e.target.value,
+                })
               }
               className="bg-background"
             />
@@ -194,7 +270,9 @@ function PastGames() {
               placeholder="Enter player name..."
               value={filters.player2}
               onChange={(e) =>
-                setFilters({ ...filters, player2: e.target.value })
+                updateFilters({
+                  player2: e.target.value,
+                })
               }
               className="bg-background"
             />
@@ -207,7 +285,9 @@ function PastGames() {
               placeholder="e.g., 1200"
               value={filters.eloMin}
               onChange={(e) =>
-                setFilters({ ...filters, eloMin: e.target.value })
+                updateFilters({
+                  eloMin: e.target.value,
+                })
               }
               className="bg-background"
             />
@@ -220,7 +300,9 @@ function PastGames() {
               placeholder="e.g., 2000"
               value={filters.eloMax}
               onChange={(e) =>
-                setFilters({ ...filters, eloMax: e.target.value })
+                updateFilters({
+                  eloMax: e.target.value,
+                })
               }
               className="bg-background"
             />
@@ -230,61 +312,99 @@ function PastGames() {
 
       {/* Games Table */}
       <Card className="overflow-hidden border-border/50 bg-card/50 backdrop-blur">
-        <Table>
-          <TableHeader>
-            <TableRow className="bg-muted/30">
-              <TableHead>Watch</TableHead>
-              <TableHead>Variant</TableHead>
-              <TableHead>Rated</TableHead>
-              <TableHead>Time Control</TableHead>
-              <TableHead>Board Size</TableHead>
-              <TableHead>Players</TableHead>
-              <TableHead>Moves</TableHead>
-              <TableHead>Views</TableHead>
-              <TableHead>Date</TableHead>
-            </TableRow>
-          </TableHeader>
-          <TableBody>
-            {games.map((game) => (
-              <TableRow key={game.id} className="hover:bg-muted/20">
-                <TableCell>
-                  <Button
-                    size="sm"
-                    variant="ghost"
-                    onClick={() => handleWatchGame(game.id)}
-                  >
-                    <Eye className="w-4 h-4" />
-                  </Button>
-                </TableCell>
-                <TableCell className="font-medium">{game.variant}</TableCell>
-                <TableCell>
-                  <Badge variant={game.rated ? "default" : "secondary"}>
-                    {game.rated ? "Yes" : "No"}
-                  </Badge>
-                </TableCell>
-                <TableCell>{game.timeControl}</TableCell>
-                <TableCell>{game.boardSize}</TableCell>
-                <TableCell>
-                  <span
-                    className={game.winner !== "Draw" ? "font-semibold" : ""}
-                  >
-                    {game.players}
-                  </span>
-                  {game.winner !== "Draw" && (
-                    <Badge className="ml-2 text-xs" variant="secondary">
-                      Winner: {game.winner}
-                    </Badge>
-                  )}
-                </TableCell>
-                <TableCell>{game.moves}</TableCell>
-                <TableCell>{game.views}</TableCell>
-                <TableCell className="text-sm text-muted-foreground">
-                  {game.date}
-                </TableCell>
+        {isPending ? (
+          <div className="flex items-center justify-center py-12 text-muted-foreground">
+            <Loader2 className="w-5 h-5 animate-spin mr-2" />
+            Loading past games...
+          </div>
+        ) : error ? (
+          <div className="text-center py-12 text-destructive">
+            {error.message}
+          </div>
+        ) : games.length === 0 ? (
+          <div className="text-center py-12 text-muted-foreground">
+            No past games match your filters.
+          </div>
+        ) : (
+          <Table>
+            <TableHeader>
+              <TableRow className="bg-muted/30">
+                <TableHead>Watch</TableHead>
+                <TableHead>Variant</TableHead>
+                <TableHead>Rated</TableHead>
+                <TableHead>Time Control</TableHead>
+                <TableHead>Board Size</TableHead>
+                <TableHead>Players</TableHead>
+                <TableHead>Moves</TableHead>
+                <TableHead>Views</TableHead>
+                <TableHead>Date</TableHead>
               </TableRow>
-            ))}
-          </TableBody>
-        </Table>
+            </TableHeader>
+            <TableBody>
+              {rows.map((row) => {
+                return (
+                  <TableRow key={row.gameId} className="hover:bg-muted/20">
+                    <TableCell>
+                      <Button
+                        size="sm"
+                        variant="ghost"
+                        onClick={() => handleWatchGame(row.gameId)}
+                      >
+                        <Eye className="w-4 h-4" />
+                      </Button>
+                    </TableCell>
+                    <TableCell className="font-medium capitalize">
+                      {row.variant}
+                    </TableCell>
+                    <TableCell>
+                      <Badge variant={row.rated ? "default" : "secondary"}>
+                        {row.rated ? "Yes" : "No"}
+                      </Badge>
+                    </TableCell>
+                    <TableCell>{row.timeControlLabel}</TableCell>
+                    <TableCell>{row.boardSizeLabel}</TableCell>
+                    <TableCell>
+                      <span className={row.winnerLabel ? "font-semibold" : ""}>
+                        {row.playersLabel}
+                      </span>
+                      {row.winnerLabel && (
+                        <Badge className="ml-2 text-xs" variant="secondary">
+                          Winner: {row.winnerLabel}
+                        </Badge>
+                      )}
+                    </TableCell>
+                    <TableCell>{row.movesCount}</TableCell>
+                    <TableCell>{row.views}</TableCell>
+                    <TableCell className="text-sm text-muted-foreground">
+                      {row.dateLabel}
+                    </TableCell>
+                  </TableRow>
+                );
+              })}
+            </TableBody>
+          </Table>
+        )}
+        <div className="flex items-center justify-between px-4 py-3 border-t border-border/40">
+          <span className="text-sm text-muted-foreground">Page {page}</span>
+          <div className="flex items-center gap-2">
+            <Button
+              size="sm"
+              variant="ghost"
+              onClick={() => setPage((prev) => Math.max(1, prev - 1))}
+              disabled={page <= 1}
+            >
+              Previous
+            </Button>
+            <Button
+              size="sm"
+              variant="ghost"
+              onClick={() => setPage((prev) => prev + 1)}
+              disabled={!hasMore}
+            >
+              Next
+            </Button>
+          </div>
+        </div>
       </Card>
     </div>
   );
diff --git a/info/past_games_feature_plan.md b/info/past_games_feature_plan.md
index 7e413b6..01e2bf1 100644
--- a/info/past_games_feature_plan.md
+++ b/info/past_games_feature_plan.md
@@ -5,24 +5,26 @@ description: Persist remote games and serve replay/past games via GET /api/games
 
 # Plan
 
-Implement persistence for completed remote games keyed by nanoid, add replay fallback to GET /api/games/:id, and add a past-games list endpoint with DB filtering and pagination. Fix timer start so clocks begin on the first move and use that timestamp as started_at.
+Implement persistence for completed remote games keyed by nanoid, add replay fallback to GET /api/games/:id, add a past-games list endpoint with DB filtering and pagination, and wire the Past Games UI to real data. Fix timer start so clocks begin on the first move and use that timestamp as started_at.
 
-## Requirements
-- Persist only remote friend/matchmaking games (no local, no bots).
-- Game IDs are nanoid strings used in URLs and stored in the DB.
-- started_at is first move time; fix timer to start on first move.
-- Persist rating_at_start and current domain outcome_reason values.
-- GET /api/games/:id returns live session data when present; otherwise returns replay with kind:"replay" and serialized state built from DB.
-- Views increment only when replay is served.
-- Past-games list endpoint supports filters and pagination with DB-level filtering, moves_count >= 2, and Guest 1/Guest 2 naming.
+## Requirements
+- Persist only remote friend/matchmaking games (no local, no bots).
+- Game IDs are nanoid strings used in URLs and stored in the DB.
+- started_at is first move time; fix timer to start on first move.
+- Persist rating_at_start and current domain outcome_reason values.
+- GET /api/games/:id returns live session data when present; otherwise returns replay with kind:"replay" and serialized state built from DB.
+- Views increment only when replay is served.
+- Past-games list endpoint supports filters and pagination with DB-level filtering, moves_count >= 2, and Guest 1/Guest 2 naming.
+- Past Games view state is not URL-shareable (no query params for filters/pagination).
 
 ## Scope
-- In:
-  - DB migration for nanoid IDs, match_type, and player_role fields.
-  - Persistence module and wiring on game finish.
-  - Replay fallback in GET /api/games/:id.
-  - Past-games list query and route.
-  - Integration tests and doc alignment.
+- In:
+  - DB migration for nanoid IDs, match_type, and player_role fields.
+  - Persistence module and wiring on game finish.
+  - Replay fallback in GET /api/games/:id.
+  - Past-games list query and route.
+  - Past Games UI data wiring.
+  - Integration tests and doc alignment.
 - Out:
   - Local games and bots.
   - New replay endpoints or WebSocket replays.
@@ -38,10 +40,11 @@ Implement persistence for completed remote games keyed by nanoid, add replay fal
 - server/routes/games.ts
 - server/db/* (persistence + queries)
 - shared/contracts/games.ts
-- shared/domain/game-state.ts
-- shared/domain/standard-notation.ts
-- tests/integration/*
-- info/game_persistance.md
+- shared/domain/game-state.ts
+- shared/domain/standard-notation.ts
+- frontend/src/routes/past-games.tsx
+- tests/integration/*
+- info/game_persistance.md
 
 ## Data model / API changes
 - Change game_id columns in games/game_details/game_players to varchar for nanoid.
@@ -52,22 +55,26 @@ Implement persistence for completed remote games keyed by nanoid, add replay fal
 - Replay response returns GameSnapshot + SerializedGameState under kind:"replay" using stored moves and config.
 
 ## Action items
-[ ] Fix timer start: set lastMoveTime on first move, and capture session started_at for persistence.
-[ ] DB migration: update schema types and add match_type and player_role fields.
-[ ] Persistence: add module to insert games/game_details/game_players in a transaction with idempotency; store rating_at_start and move notations.
-[ ] Wire persistence on game end (move/resign/draw/timeout) before session cleanup.
-[ ] GET /api/games/:id: if session not found, load from DB and return kind:"replay" with reconstructed state.
-[ ] Integration test: replay fallback works for completed game (no live session).
-[ ] Views: increment on replay response; add view-count assertion in integration test.
-[ ] Past-games query endpoint: DB-level filters, pagination, moves_count >= 2, guest naming.
-[ ] Integration tests for past-games endpoint filters and pagination.
-[ ] Update info/game_persistance.md to match nanoid IDs, match_type/player_role, and outcome vocab.
+[x] Fix timer start: set lastMoveTime on first move, and capture session started_at for persistence.
+[x] DB migration: update schema types and add match_type and player_role fields.
+[x] Persistence: add module to insert games/game_details/game_players in a transaction with idempotency; store rating_at_start and move notations.
+[x] Wire persistence on game end (move/resign/draw/timeout) before session cleanup.
+[x] GET /api/games/:id: if session not found, load from DB and return kind:"replay" with reconstructed state.
+[x] Integration test: replay fallback works for completed game (no live session).
+[x] Views: increment on replay response; add view-count assertion in integration test.
+[x] Past-games query endpoint: DB-level filters, pagination, moves_count >= 2, guest naming.
+[x] Integration tests for past-games endpoint filters and pagination.
+[x] Update info/game_persistance.md to match nanoid IDs, match_type/player_role, and outcome vocab.
+[x] Past Games UI: replace mock data with /api/games/past and map filters/pagination.
+[x] Past Games UI: render real game rows with loading, empty, and error states.
+[x] Past Games UI: keep filters/page in local state only; reset page to 1 on filter change.
 
 ## Testing and validation
 - Integration: finish game, clear session, GET /api/games/:id returns replay with correct snapshot/state.
 - Integration: views increment only for replay.
-- Integration: past-games endpoint respects filters and returns correct counts.
-- Manual: play remote game, reload URL after completion, verify replay renders.
+- Integration: past-games endpoint respects filters and returns correct counts.
+- Manual: play remote game, reload URL after completion, verify replay renders.
+- Manual: load /past-games, adjust filters, paginate, and watch a replay.
 
 ## Risks and edge cases
 - Duplicate persistence on multiple end triggers; guard with idempotency.
diff --git a/server/db/game-queries.ts b/server/db/game-queries.ts
index 2996942..0da772e 100644
--- a/server/db/game-queries.ts
+++ b/server/db/game-queries.ts
@@ -23,6 +23,10 @@ import type {
 } from "../../shared/domain/game-types";
 import { timeControlConfigFromPreset } from "../../shared/domain/game-utils";
 import { moveFromStandardNotation } from "../../shared/domain/standard-notation";
+import {
+  BOARD_SIZE_AREA_MEDIUM_MAX,
+  BOARD_SIZE_AREA_SMALL_MAX,
+} from "../../shared/domain/past-games";
 import type { PastGamesResponse } from "../../shared/contracts/games";
 
 const buildMatchScore = (result: GameResult | undefined): MatchScore => {
@@ -348,11 +352,13 @@ export const queryPastGames = async (args: {
   if (args.boardSize) {
     const area = sql`${gamesTable.boardWidth} * ${gamesTable.boardHeight}`;
     if (args.boardSize === "small") {
-      conditions.push(sql`${area} <= 36`);
+      conditions.push(sql`${area} <= ${BOARD_SIZE_AREA_SMALL_MAX}`);
     } else if (args.boardSize === "medium") {
-      conditions.push(sql`${area} > 36 AND ${area} <= 81`);
+      conditions.push(
+        sql`${area} > ${BOARD_SIZE_AREA_SMALL_MAX} AND ${area} <= ${BOARD_SIZE_AREA_MEDIUM_MAX}`,
+      );
     } else {
-      conditions.push(sql`${area} > 81`);
+      conditions.push(sql`${area} > ${BOARD_SIZE_AREA_MEDIUM_MAX}`);
     }
   }
 
diff --git a/tests/integration/past-games.test.ts b/tests/integration/past-games.test.ts
index 1f09ed8..00e9670 100644
--- a/tests/integration/past-games.test.ts
+++ b/tests/integration/past-games.test.ts
@@ -366,5 +366,21 @@ describe("past games persistence", () => {
     const smallBoardGames = (await resBoard.json()) as PastGamesResponse;
     expect(smallBoardGames.games.length).toBe(1);
     expect(smallBoardGames.games[0]?.gameId).toBe(gameB);
+
+    const resBoardMedium = await fetch(
+      `${baseUrl}/api/games/past?boardSize=medium&page=1&pageSize=10`,
+    );
+    expect(resBoardMedium.status).toBe(200);
+    const mediumBoardGames = (await resBoardMedium.json()) as PastGamesResponse;
+    expect(mediumBoardGames.games.length).toBe(1);
+    expect(mediumBoardGames.games[0]?.gameId).toBe(gameA);
+
+    const resBoardLarge = await fetch(
+      `${baseUrl}/api/games/past?boardSize=large&page=1&pageSize=10`,
+    );
+    expect(resBoardLarge.status).toBe(200);
+    const largeBoardGames = (await resBoardLarge.json()) as PastGamesResponse;
+    expect(largeBoardGames.games.length).toBe(1);
+    expect(largeBoardGames.games[0]?.gameId).toBe(gameC);
   });
 });
