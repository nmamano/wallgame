---
alwaysApply: true
---

# Principles

- The app is not finished/launched yet, so we want the architecture to be correct from the start. Don't add things for backward compatibility - there is no data yet.
- Do abstractions right, not fast. Don't introduce tech debt.
- When renaming or moving shared types, avoid re-exporting them for backward compatibility. Try to just update all references at once.
- Avoid optionality. Optionality hides bugs because it collapses "unknown" and "not provided." If a value is required for correctness, it must be: non-optional, and explicitly nullable when unknown.
- If UI bugs persist, stop coding and trace truth flow.
- Explicit is better than implicit. Unknown beats wrong. When the client infers instead of being told, we often end with a race condition. Avoid this pattern.
- It is encouraged to identify issues as we move toward the north star design and take detours to clean them up.
- Avoid temporary flows or dual flows.

# Tools

- Use bun, not npm, pnpm, etc. If you need, the actual bun installation is at `/c/Users/Nilo/.bun/bin/bun`.
- If you deem it necessary, when finishing a task, you can run `bun run test`, `bun run lint`, and `bun run build` to ensure that the tests, linting, and build pass. Optionally, you can run `bun run format`.
- Always use Linux-style line endings when editing files.

# Organization

- All tests go in `tests/`.
- Every type used across the frontend-server boundary must be in `shared/contracts/`.
- If you need new UI components they may be in `frontend/src/components/unused-components/`. Read `frontend/src/components/unused-components/RE_ADDING_COMPONENTS.md` for how to re-add them.

# Architecture

Read `info/architecture.md` for the current architecture.

Sticking to this architecture ensures that:

- UI/logic changes stay transport-agnostic.
- Spectators remain first-class citizens.
- Future expansions (additional controller types or transport layers) can slot in with minimal churn.

Read `info/game_lifecycle_design.md` for the current game lifecycle design.

# Business logic

- Player 1/2 determines who starts (Player 1 always starts) and the starting pawn positions. This is known as Player ID. On the game setup page, players are setup as Player A/B. It corresponds to the `role` field: "host" | "joiner", as Player A is always the host. Who becomes Player 1 is random.
