---
alwaysApply: true
---

# Principles

- The app is not finished/launched yet, so we want the architecture to be correct from the start. Don't add things for backward compatibility - there is no data yet.
- Do things right, not fast. Don't introduce tech debt.
- When renaming or moving shared types, avoid re-exporting them for backward compatibility. Try to just update all references at once.

# Tools

- Use bun, not npm, pnpm, etc. If you need, the actual bun installation is at `/c/Users/Nilo/.bun/bin/bun`.
- If you deem it necessary, when finishing a task, you can run `bun run test`, `bun run lint`, and `bun run build` to ensure that the tests, linting, and build pass. Optionally, you can run `bun run format`.

# Organization

- All tests go in `tests/`.
- Every type used across the frontend-server boundary must be in `shared/contracts/`.
- If you need new UI components they may be in `frontend/src/components/unused-components/`. Read `frontend/src/components/unused-components/RE_ADDING_COMPONENTS.md` for how to re-add them.

# Architecture

Read `info/architecture.md` for the current architecture.

Sticking to this architecture ensures that:

- UI/logic changes stay transport-agnostic.
- Spectators remain first-class citizens.
- Future expansions (additional controller types or transport layers) can slot in with minimal churn.

# Business logic

- Player 1/2 determines who starts (Player 1 always starts) and the starting pawn positions. This is known as Player ID. On the game setup page, players are setup as Player A/B. It corresponds to the `role` field: "host" | "joiner", as Player A is always the host. Who becomes Player 1 is random.
